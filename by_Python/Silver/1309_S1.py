'''
  사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수 없다
  --> 2*N 배열에 사자를 배치하는 경우의 수? 
      (사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다)
  
  --> 우선 2 * N 크기의 배열 zoo_board 선언
  --> 사방을 탐색해야 해서 사방을 탐색하기 위한 배열 dx, dy 활용
  --> 사방을 탐색할 때, 중복 탐색 방지를 위해서 visited 배열 (최대 2*100,000 Byte일 것임 / Boolean 배열)
  --> 각 칸을 검사 (그 옆칸을 검사하면서, 계속 재귀로 타고 내려가야 할 듯)
    => 그 칸에 동물이 없으면, 사방의 칸에는 동물이 올수도 있고, 안 올수도 있음
    => 그 칸에 동물이 있으면, 사방의 칸에는 동물이 무조건 오면 안됨
  --> 각 칸에 동물이 있는 경우 / 없는 경우에 대해서 재귀 활용해서 모두 탐색 (DFS)

  [처음엔 위처럼 생각했으나... 생각해보니 다 탐색하는 게 말이 안됨. 시간 초과 날 것 같다. / DP?]
  --> 한 행에 대해서, 동물이 존재할 수 있는 경우는 3가지 밖에 없음
    o x (0), x o (1), x x(2) 라고 할 때..
    ==> 0의 경우에 대해 그 다음 행에는.. 1 또는 2의 경우만 올 수 있음
    ==> 1의 경우에 대해 그 다음 행에는.. 0 또는 2의 경우만 올 수 있음
    ==> 2의 경우에 대해 그 다음 행에는.. 0, 1, 2의 경우 모두 올 수 있음
    (뭔가 DP로 풀라는 냄새..(메모이제이션...?)가 솔솔 나죠? / dp는 점화식을 세워야 한다고 하더라)
    => dp[i][0]('0'의 경우에 대해서 올 수 있는 가짓수) = dp[i-1][1] + dp[i-1][2]
    => dp[i][1]('1'의 경우에 대해서 올 수 있는 가짓수) = dp[i-1][0] + dp[i-1][2]
    => dp[i][2]('2'의 경우에 대해서 올 수 있는 가짓수) = dp[i-1][0] + dp[i-1][1] + dp[i-1][2]
'''
import sys

input = sys.stdin.readline
MOD = 9901

N = int(input().strip()) # 우리의 크기 입력 받기

dp = [] # 메모이제이션을 위한 배열

dp.append([1, 1, 1])

#점화식을 이용해서 dp 배열의 N-1번째 인덱스까지 돌린다
for i in range(1, N):
  dp.append([(dp[i-1][1] + dp[i-1][2]) % MOD, (dp[i-1][0] + dp[i-1][2]) % MOD, (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % MOD])

print(sum(dp[N-1]) % MOD)